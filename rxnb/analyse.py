from rdkit import Chem
import numpy as np
pt = Chem.GetPeriodicTable()
class G16Log_Parser():
    
    def __init__(self,log_file,types=['sp']):
        '''
        Parser for G16 log files, designed to parse '.log' files generated by G16 to extract single-point energies, optimized structures, or to check if the optimized structures are valid stationary points.
        
        Parameters
        ----------
        log_file : string
            Path to g16 .log file
        types : list
            List of G16 tasks, support single point energy (sp), geometry optimization (opt) and frequency calculation (freq).
            
        Returns
        -------
        G16 log parser object.
        '''
        self.log_file = log_file
        self.types = [type_.lower() for type_ in types]
        with open(self.log_file,'r') as fr:
            self.loginf = fr.readlines()
        if not self.is_done():
            raise ValueError('G16 procedure not finished or failed')
    
    def is_done(self):
        '''
        Check if the G16 program has terminated normally.
        
        Returns
        -------
        is_done : bool
            If the G16 program has terminated normally or not.
        '''
        return 'Normal termination of Gaussian' in self.loginf[-1]
    
    def read_energy(self):
        '''
        Read single point energy (last one will return if optimization task is performed)
        
        Returns
        -------
        sp_energy : float
            single point energy
        '''
        assert 'sp' in self.types, "No 'sp' in `types` parameter"
        sp_energy_lst = []
        for line in self.loginf:
            if 'SCF Done:' in line:
                sp_energy_lst.append(eval(line.strip().split()[4]))
        if sp_energy_lst == []:
            raise ValueError('No single point energy found')
        else:
            self.sp_energy = sp_energy_lst[-1]
            return sp_energy_lst[-1]
    
    def read_opted_geom(self):
        '''
        Read optimized molecular geometry
        
        Parameters
        ----------
        
        Returns
        -------
        atom_types : numpy.ndarray
            ndarray of atom types
        coords : numpy.ndarray
            ndarray of coordinates
        '''
        assert 'opt' in self.types, "No 'opt' in `types` parameter"
        coord_start_index_list = []
        atom_num = None
        for i,line in enumerate(self.loginf):
            if 'NAtoms=' in line and atom_num == None:
                atom_num = eval(line.split()[1])
                self.atom_num = atom_num
            if 'Standard orientation' in line:
                coord_start_index_list.append(i+5)
        coord_string = self.loginf[coord_start_index_list[-1]:coord_start_index_list[-1]+atom_num]
        coords = np.array([[eval(item.strip().split()[3]),eval(item.strip().split()[4]), eval(item.strip().split()[5])] for item in coord_string])
        atom_types = np.array([pt.GetElementSymbol(eval(item.split()[1])) for item in coord_string])
        self.coords = coords
        self.atom_types = atom_types
        return atom_types, coords
    
    def read_therm_inf(self):
        '''
        Read thermal correction information
        
        Returns
        -------
        TCG : float
            Thermal correction to Gibbs Free Energy
        TCH : float
            Thermal correction to Enthalpy
        '''
        
        assert 'freq' in self.types, "No 'freq' in `types` parameter"
        TCH = 0
        TCG = 0
        for line in self.loginf:
            if 'Thermal correction to Enthalpy' in line:
                TCH = eval(line.strip().split()[4])
            if 'Thermal correction to Gibbs Free Energy' in line:
                TCG = eval(line.strip().split()[6])
        if TCH == 0 or TCG == 0:
            raise ValueError('Thermal correction information not found')
        
        self.TCH = TCH
        self.TCG = TCG
        return TCG,TCH
        
    def read_freq(self):
        '''
        Read frequency information
        
        Returns
        -------
        freq_arr : numpy.ndarray
            ndarray of atom vibrational frequency
        mod_arr : numpy.ndarray
            ndarray of atom vibration displacement
        '''
        try:
            atom_num = self.atom_num
            freq_blk_num = (atom_num * 3 - 6) // 3
        except:
            atom_num = None
        
        freq_lst = []
        mod_lst = []
        for idx,line in enumerate(self.loginf):
            if atom_num == None and 'NAtoms=' in line:
                atom_num = eval(line.split()[1])
                self.atom_num = atom_num
                freq_blk_num = (atom_num * 3 - 6) // 3
            elif 'Harmonic frequencies (cm**-1), IR intensities (KM/Mole), Raman scattering' in line:
                for i in range(freq_blk_num):
                    freq_inf_blk = self.loginf[idx+4+i*(atom_num+7):idx+4+(i+1)*(atom_num+7)]
                    freq_lst += list(map(float,freq_inf_blk[2].strip().split()[-3:]))
                    mod_trip_ens = np.array([list(map(float,inf.strip().split()[2:])) for inf in freq_inf_blk[7:]])
                    mod_lst += [mod_trip_ens[:,:3],mod_trip_ens[:,3:6],mod_trip_ens[:,6:9]]
        freq_arr = np.array(freq_lst)
        mod_arr = np.array(mod_lst)
        self.freq_arr = freq_arr
        self.mod_arr = mod_arr
        return freq_arr,mod_arr
        
    def is_valid_statpt(self,key_bond=[1,2],tsk_type='normal',th=1.0):
        '''
        Check if the optimized structures are valid stationary points.
        
        Parameters
        ----------
        key_bond : list
            The indices of atoms at the ends of the breaking or forming bond in the transition state, with atom indices starting from 1.
        tsk_type : string
            The task type should be 'normal' or 'ts', which represent stationary points for regular optimization and transition state optimization, respectively.
        th : float
            Threshold for the critical bond length change in the imaginary frequency vibration of the transition state.
            
        Returns
        ----------
        is_valid : bool
            If the optimized molecule is converged to valid stationary point or not.
        '''
        tsk_type = tsk_type.lower()
        assert 'freq' in self.types, "No 'freq' in `types` parameter"
        assert tsk_type in ['normal','ts'], "`tsk_type` should be 'normal' or 'ts'"
        key_bond = [idx-1 for idx in key_bond]    
        freq_arr,mod_arr = self.read_freq()
    
        if tsk_type == 'normal':
            if freq_arr[0] <= 0:
                return False
            else:
                return True
        elif tsk_type == 'ts':
            if freq_arr[0] >= 0 or freq_arr[1] <= 0:
                return False
            else:
                dis_of_key_bond = np.linalg.norm(mod_arr[0][key_bond[0]]-mod_arr[0][key_bond[1]])
                
                if dis_of_key_bond >= th:
                    return True
                else:
                    return False